import ctypesimport ConfigParserimport systry:    import logger    log = logger.getlogger()except:    import logging    log = logging.getlogger()try:    config = ConfigParser.RawConfigParser()    config.read('blink.cfg')    PAFBlinkFolder = config.get('blink', 'dir')except ConfigParser.NoSectionError:    #PAFBlinkFolder = r'c:\Program Files\PrintSoft\Blink'    PAFBlinkFolder = r'C:\Program Files\DataTools\Paf'errorDescription={0: '00.DPRC_OK', 1: '01.DPRC_POSTCODE', 2: '02.DPRC_STATE', 3: '03.DPRC_LOCALITY', 4: '04.DPRC_THOROUGH_FARE_NAME', 5: '05.DPRC_AMBIGUOUS', 6: '06.DPRC_ADDRESS_NUMBER', 7: '07.DPRC_POSTAL_TYPE', 8: '08.DPRC_POSTAL_TYPE_NUMBER', 9: '09.DPRC_PHANTOM', 10: '10.DPRC_BUILDING_TYPE', 11: '11.DPRC_DPID', 12: '12.DPRC_ALLOTMENT', 13: '13.DPRC_BLDG_NAME', 14: '14.DPRC_INV_FIELD', 15: '15.DPRC_PARSER', 16: '16.DPRC_PRIMARY_POINT', 17: '17.DPRC_CLOSE', 18: '18.DPRC_PARSER_WARNING', 19: '19.DPRC_BARCODE_WARNING', 20: '20.DPRC_FCC_WARNING', 21: '21.DPRC_OLD_PAF'}#AusGap.dll, aufilters.dll, AuBase.dll, GapEnglish.dll, Gap.dll, libcgap.dll, pafpardll.dll#If not found in c:\windows\, copy those files from paflinkfolder to c:\windows\#dllFiles = ['AusGap.dll', 'aufilters.dll', 'AuBase.dll', 'GapEnglish.dll', 'Gap.dll', 'libcgap.dll', 'pafpardll.dll','MSVCP60.dll','msvcp71.dll','msvcr71.dll']#dllFiles = ['AusGap.dll', 'aufilters.dll', 'AuBase.dll', 'GapEnglish.dll', 'Gap.dll', 'libcgap.dll', 'pafpardll.dll']#dllFiles = ['pafpardll.dll']#for dllFile in dllFiles:#    #if os.path.exists('c:\windows'+os.sep+dllFile) == T:#    shutil.copy(PAFLinkFolder+os.sep+dllFile, 'c:\windows'+os.sep+dllFile)class BlinkWrapper():    """        Wrapper Class for ACXIOM C API        #After successfully loading these libraries, now we are able to access         C API        #DPE_OpenFiles                   Opens index and data files, load the                                         parser interpreter and its associated                                         data tables.        #DPE_NewQis                      Returns a handle that is used in                                         subsequent queries.        #DPE_SetInTemplate        #DPE_SetOutTemplate        #                                These two functions set the input and                                         output templates, in the same manner                                         as the 'T' and 'O' command codes in the                                         batch engine. Note that the separator                                         character is a separate parameter to                                         these functions, not the first character                                         as in the 'T' and 'O' lines.        #DPE_SearchAMAS                  After the templates are defined, the search function can be called        #                                repeatedly. This will return one record for a complete input address. It is        #                                the AMAS compatible function.        #DPE_SearchNearest               If a search for near addresses is desired, the function can be called        #                                repeatedly. This will return multiple records. Normally used instead of        #DPE_SearchAMAS        #DPE_DisposeQis        #DPE_CloseFiles        #                                Finally, to clean up the library, use these two functions    """    BUFFER = 500    def __init__(self):        self.dll = ctypes.windll.LoadLibrary('pafpardll.dll')        path = ctypes.c_char_p(PAFBlinkFolder)        result = self.dll.DPE_OpenFiles(path)        if result > 0:            log.info(errorDescription[result][4:])            log.info("Does %s folder exists?" % PAFBlinkFolder)            log.info("If not, please put paflink folder in addr.cfg")            raise RuntimeError(errorDescription[result][4:])        self.qis = self.dll.DPE_NewQis()    def setInTemplate(self, inStr, delimeter='|'):        sep = ctypes.c_char(delimeter)        inTemplate = ctypes.c_char_p(delimeter.join(inStr))        return self.dll.DPE_SetInTemplate(self.qis, sep, inTemplate)    def setOutTemplate(self, outStr, delimeter='|'):        self.outputTemplate = outStr        self.outDelimeter = delimeter        sep = ctypes.c_char(delimeter)        outTemplate = ctypes.c_char_p(delimeter.join(outStr))        return self.dll.DPE_SetOutTemplate(self.qis, sep, outTemplate)    def searchAMAS(self, query):        cnt = ctypes.c_uint(0)        ptr_query = ctypes.c_char_p(query)        ptr_buffer = ctypes.create_string_buffer(500)        res = self.dll.DPE_SearchAMAS(self.qis, ptr_query, ptr_buffer, ctypes.byref(cnt), ctypes.sizeof(ptr_buffer))        result = {}        if res == 0 or res == 11:            for i in range(len(self.outputTemplate)):                try:                    result[self.outputTemplate[i]] = ptr_buffer.value.split(self.outDelimeter)[i]                except IndexError:                    result[self.outputTemplate[i]] = '0'        else:            print query            print res            raise RuntimeError("Something wrong %d" % res)        return result        def searchAMASRaw(self, query):        cnt = ctypes.c_uint(0)        ptr_query = ctypes.c_char_p(query)        ptr_buffer = ctypes.create_string_buffer(500)        res = self.dll.DPE_SearchAMAS(self.qis, ptr_query, ptr_buffer, ctypes.byref(cnt), ctypes.sizeof(ptr_buffer))                if res == 0:            pass        else:            raise RuntimeError("Something wrong %d" % res)        return ptr_buffer.value.strip()            def setAnswerFormat(self, preChar=' ', postChar='>'):        self.outputPostChar = postChar        c_preChar = ctypes.c_char(preChar)        c_postChar = ctypes.c_char(postChar)        return self.dll.DPE_SetAnswerFormat(self.qis, ctypes.byref(c_preChar), ctypes.byref(c_postChar))    def searchNearest(self, query):        cnt = ctypes.c_uint(0)        ptr_query = ctypes.c_char_p(query)        factor = 1        ptr_buffer = ctypes.create_string_buffer(BlinkWrapper.BUFFER*factor)        res = self.dll.DPE_SearchNearest(self.qis, ptr_query, ptr_buffer, ctypes.byref(cnt), ctypes.sizeof(ptr_buffer))        results = []        #print res        while res > 0 and factor < 1000000:            factor *= 10            #print "buffer at =%d" % (self.resultBUFFER*factor)            ptr_buffer = ctypes.create_string_buffer(BlinkWrapper.BUFFER*factor)            res = self.dll.DPE_SearchNearest(self.qis, ptr_query, ptr_buffer, ctypes.byref(cnt), ctypes.sizeof(ptr_buffer))        if factor >= 1000000 and res == 0:            raise RuntimeError("Buffer is overflow %d" % (BlinkWrapper.BUFFER*factor))        if res == 0:            tempList = ptr_buffer.value.split(self.outputPostChar)            del ptr_buffer            if cnt.value == (len(tempList)-1):                for i in range(len(tempList)-1):                    tempDict = {}                    for j in range(len(self.outputTemplate)):                        tempList[i].split(self.outDelimeter)[j]                        tempDict[self.outputTemplate[j]] = tempList[i].split(self.outDelimeter)[j]                    results.append(tempDict)        else:            log.info("Something wrong %d" % res)            log.info("Increase buffer current=%d" % self.resultBUFFER)            raise RuntimeError("Something wrong %d" % res)        return results    def getBarcode(self, query):        cnt = ctypes.c_uint(0)        ptr_query = ctypes.c_char_p(query)        ptr_buffer = ctypes.create_string_buffer(500)        res = self.dll.DPE_Barcode(self.qis, ptr_query, ptr_buffer, ctypes.byref(cnt), ctypes.sizeof(ptr_buffer))        if res == 0:            pass        else:            print "Something wrong %d" % res            sys.exit()        return ptr_buffer.value.strip()    def cleanUp(self):        log.info("Im now freeing from memory")        self.dll.DPE_DisposeQis(self.qis)        self.dll.DPE_CloseFiles()## def generateAMASInStr(AMASInputTemplate):#     result = {}#     for i in range(len(AMASInputTemplate)):#         result[AMASInputTemplate[i][0].upper()] = AMASInputTemplate[i][1]#     return result### def generateAMASOutStr(AMASOutputTemplate):#     result = {}##     for i in range(len(AMASOutputTemplate)):#         result[AMASOutputTemplate[i][0]] = AMASOutputTemplate[i][1]#     return result### def getHeaderIndex(AMASInputTemplate, headerList):#     result = {}##     for i in range(len(AMASInputTemplate)):#         result['AD%d' % (i+1)] = headerList.index(AMASInputTemplate['AD%d' % (i+1)])#     return resultif __name__ == '__main__':    blink = BlinkWrapper()    blink.setInTemplate(['ADR'])    blink.setOutTemplate(['BAR','STT'])    #print blink.getBarcode('53971256|00|C|#153216zzz')    #print blink.getBarcode('00000000|62|C|#153216zzz')    #print blink.getBarcode('00000000|62|C|#206338zzz')    log.info(blink.searchAMASRaw("51 Honour Ave Wyndham Vale 3024"))    blink.cleanUp()